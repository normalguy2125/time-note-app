// script.js\n// Core logic for Time Note - Mobile-First Timestamp Logging App\n\n// ----------- State Management -----------\nconst display = document.getElementById('display');\nconst keyboard = document.querySelector('.keyboard');\nconst undoBtn = document.getElementById('undoBtn');\nconst redoBtn = document.getElementById('redoBtn');\nconst copyBtn = document.getElementById('copyBtn');\nconst downloadBtn = document.getElementById('downloadBtn');\n\nlet logs = [];               // Array of {number:int, entries:string} for each line\nlet inputBuffer = '';        // Current input on line (string)\nlet mode = 'mm';             // Current mode: 'mm' | 'ss' | 'connector' | 'new'\nlet entryConnect = ',(';     // Default auto connector after timestamps\nlet cursorPos = 0;           // Not actual pos; inputBuffer positions handled in logic\nlet undoStack = [];\nlet redoStack = [];\nlet lastClearTime = 0;\n\n// ----------- Utility ----------\nfunction getCurrentDateStr() {\n  const d = new Date();\n  return d.toISOString().slice(0, 10);\n}\nfunction escapeHtml(str) {\n  // Needed for rendering user input safely inside <pre>\n  return str.replace(/[&<>'"]/g, tag => ({\n    '&':'&amp;','<':'&lt;','>':'&gt;','\'':'&#39;','"':'&quot;'\n  }[tag]));\n}\n\n// ----------- Rendering Logic -----------\nfunction render() {\n  let out = '';\n  logs.forEach((line, idx) => {\n    out += `${line.number})\n${line.entries}`;\n    if (idx !== logs.length - 1) out += '\n';\n  });\n\n  // When editing, show blinking cursor\n  if (mode !== 'new') {\n    out += inputBuffer && !inputBuffer.endsWith('▋') ? '▋' : '';\n    if (inputBuffer.endsWith('▋')) out += '';\n    else out += '';\n  } else {\n    out += '';\n  }\n\n  // Remove stray cursor in finalized lines\n  let pretty = out.replace(/▋+/g, '<span class="blink-cursor">▋</span>');\n  display.innerHTML = pretty;\n  scrollDisplayToCursor();\n}\n\nfunction scrollDisplayToCursor() {\n  // Keep viewport near the cursor for rapid data entry\n  setTimeout(() => {\n    display.parentElement.scrollTop = display.parentElement.scrollHeight;\n  }, 0);\n}\n\n// ----------- Initializer -----------\nfunction initialize() {\n  logs = [{number:1, entries:'('}];\n  inputBuffer = '';\n  mode = 'mm'; // start in minutes position\n  cursorPos = 0;\n  undoStack = [];\n  redoStack = [];\n  render();\n}\ninitialize();\n\n// ----------- Undo/Redo Logic -----------\nfunction pushState() {\n  undoStack.push(JSON.stringify({ logs: logs, inputBuffer, mode, cursorPos }));\n  // Reset redo stack on new action\n  redoStack = [];\n  if (undoStack.length > 100) undoStack.shift();\n}\nfunction undo() {\n  if (!undoStack.length) return;\n  redoStack.push(JSON.stringify({ logs: logs, inputBuffer, mode, cursorPos }));\n  let prev = JSON.parse(undoStack.pop());\n  logs = JSON.parse(JSON.stringify(prev.logs));\n  inputBuffer = prev.inputBuffer;\n  mode = prev.mode;\n  cursorPos = prev.cursorPos;\n  render();\n}\nfunction redo() {\n  if (!redoStack.length) return;\n  pushState();\n  let next = JSON.parse(redoStack.pop());\n  logs = JSON.parse(JSON.stringify(next.logs));\n  inputBuffer = next.inputBuffer;\n  mode = next.mode;\n  cursorPos = next.cursorPos;\n  render();\n}\n\n// ------------ Main Input Logic -------------\n// Handles digit or input key pressed\nfunction handleKey(key) {\n  // Prevent default focus\n  display.blur();\n\n  // For clarity, all logic is split per key type\n  pushState();\n\n  // --- Clear Function (C) ---\n  if (key === 'C') {\n    let now = Date.now();\n    if (now - lastClearTime < 500) {\n      // Double tap: clear all\n      logs = [{number:1, entries:'('}];\n      inputBuffer = '';\n      mode = 'mm';\n    } else {\n      // Single tap: clear current entry\n      inputBuffer = '';\n      if (logs.length) logs[logs.length-1].entries = '(';\n      mode = 'mm';\n    }\n    lastClearTime = now;\n    render();\n    return;\n  }\n\n  // --- Backspace (⌫) ---\n  if (key === '⌫') {\n    if (inputBuffer.length) {\n      inputBuffer = inputBuffer.slice(0, -1);\n      logs[logs.length-1].entries = logs[logs.length-1].entries.slice(0, -1);\n      if (mode === 'ss' && inputBuffer.endsWith(':')) mode = 'mm';\n      render();\n    } else if (logs.length > 1 && logs[logs.length-1].entries === '(') {\n      // If empty on new line, delete it\n      logs.pop();\n      mode = 'mm';\n      inputBuffer = '';\n      render();\n    }\n    return;\n  }\n\n  // --- Undo / Redo ---\n  if (key === 'UNDO') { undo(); return; }\n  if (key === 'REDO') { redo(); return; }\n\n  // --- ( ) , : Manual entries ---\n  if (['(',')',',',':'].includes(key)) {\n    inputBuffer += key;\n    logs[logs.length-1].entries += key;\n    render();\n    return;\n  }\n\n  // --- Plus/Minus Control ---\n  if (['+','-'].includes(key)) {\n    const lastEntry = logs[logs.length-1].entries;\n    if (/({2}:{2}),\($/.test(lastEntry)) {\n      logs[logs.length-1].entries = lastEntry.replace(/,\($/, key+'(');\n      render();\n      mode = 'mm';\n      inputBuffer += key+'('; // Update buffer for integrity\n    }\n    return;\n  }\n\n  // --- Number Entry: Digits ---\n  if (/^[0-9]$/.test(key)) {\n    if (mode === 'mm') {\n      inputBuffer += key;\n      logs[logs.length-1].entries += key;\n      if (inputBuffer.replace(/[^0-9]/g,'').length === 2) {\n        inputBuffer += ':';\n        logs[logs.length-1].entries += ':';\n        mode = 'ss';\n      }\n      render();\n      return;\n    } else if (mode === 'ss') {\n      inputBuffer += key;\n      logs[logs.length-1].entries += key;\n      if (inputBuffer.split(':')[1] && inputBuffer.split(':')[1].length === 2) {\n        // Timestamp completed\n        logs[logs.length-1].entries += '),('; \n        inputBuffer += '),('; \n        mode = 'mm'; \n      }\n      render();\n      return;\n    }\n  }\n\n  // --- OK Button Logic ---\n  if (key === 'OK') {\n    if (mode === 'mm') {\n      let mm = inputBuffer.replace(/[^0-9]/g,'');\n      if (mm.length === 1) {\n        inputBuffer = '0' + mm + ':';\n        logs[logs.length-1].entries += '0' + mm + ':';\n        mode = 'ss';\n        render();\n      }\n    } else if (mode === 'ss') {\n      let segs = inputBuffer.split(':');\n      let mm = segs[0]||'00', ss = segs[1]||'';\n      if (ss.length === 1) {\n        inputBuffer = segs[0] + ':' + '0'+ss + '),('; \n        logs[logs.length-1].entries += '0'+ss + '),('; \n        mode = 'mm'; \n        render();\n      }\n    }\n    return;\n  }\n\n  // --- Enter Button Logic ---\n  if (key === 'Enter') {\n    let line = logs[logs.length-1].entries;\n    // Case 1: after full timestamp (endswith ),( or )+(!)\n    if (/({2}:{2})([,+\-])?\($/.test(line)) {\n      // Remove connector, finalize line\n      logs[logs.length-1].entries = line.replace(/([,+\-])\($/, ')');\n      // Start next log\n      logs.push({number: logs.length+1, entries:'('});\n      inputBuffer = '';\n      mode = 'mm';\n      render();\n      return;\n    }\n    // Case 2: after single digit in ss\n    if (/:$/.test(line)) {\n      logs[logs.length-1].entries = line.replace(/:$/, function(_,d){\n        return ':0'+d+')';\n      });\n      logs.push({number: logs.length+1, entries:'('});\n      inputBuffer = '';\n      mode = 'mm';\n      render();\n      return;\n    }\n    // Case 3: empty new line\n    if (line === '(' && logs.length > 1) {\n      logs.pop();\n      inputBuffer = '';\n      mode = 'mm';\n      render();\n      return;\n    }\n    // Case 4: All others: no-op\n    return;\n  }\n}\n\n// ----------- Keyboard Delegation -----------\nkeyboard.addEventListener('click', function(e) {\n  if (!e.target.classList.contains('key')) return;\n  const key = e.target.dataset.key;\n  handleKey(key);\n});\n\n// ----------- Header Button Logic -----------\n// COPY\ncopyBtn.addEventListener('click', function() {\n  const content = finalizeContent();\n  navigator.clipboard.writeText(content).then(()=> {\n    copyBtn.textContent = "COPIED!";\n    setTimeout(()=>{copyBtn.textContent = "COPY";}, 1000);\n  });\n});\n\nfunction finalizeContent() {\n  // Clean display for output (remove trailing connectors, unfinished timestamp, extra cursor)\n  let content = '';\n  logs.forEach((line, idx) => {\n    let entry = line.entries.replace(/([,+\-])\($/g, ')');\n    entry = entry.replace(/▋$/, '');\n    entry = entry.replace(/\(([0-9]{1,2}):([0-9]{1,2})$/, function(_,mm, ss) {\n      // If timestamp is incomplete (e.g., (05:1), make it (05:01))\n      if (ss.length === 1) return `(${mm}:0${ss})`;\n      return `(${mm}:${ss})`;\n    });\n    content += `${line.number})\n${entry}`;\n    if (idx !== logs.length - 1) content += '\n';\n  });\n  return content;\n}\n\n// DOWNLOAD\ndownloadBtn.addEventListener('click', function() {\n  const filename = `timenotes_${getCurrentDateStr()}.txt`;\n  const content = finalizeContent();\n  const blob = new Blob([content], {type: 'text/plain'});\n  const link = document.createElement('a');\n  link.href = URL.createObjectURL(blob);\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  setTimeout(()=>document.body.removeChild(link),150);\n});\n\n// ----------- Undo/Redo Button Logic --------\nundoBtn.addEventListener('click', () => handleKey('UNDO'));\nredoBtn.addEventListener('click', () => handleKey('REDO'));\n\n// ----------- Accessibility: Swipe to keyboard -----------\n// (If you'd like to support "tap" to focus keyboard, simply listen on .main-content for event)\n// Optional: trap virtual keyboard for mobile if wanted, but not needed here\n\n// ----------- Resize Handler: Adaptive Safe Area -----------\nfunction adjustKeyboardForSafeArea() {\n  // For Android/iOS rounded screens, make sure keyboard is right above system bar\n  document.querySelector('.keyboard').style.paddingBottom =\n    (window.innerHeight - document.body.offsetHeight > 34)\n    ? '34px' : '6px';\n}\nwindow.addEventListener('resize', adjustKeyboardForSafeArea);\n\n// ----------- Prevent Mobile Scroll In Main Content ----------\ndocument.body.addEventListener('touchmove', function(e) {\n  if (e.target.closest('.main-content') || e.target.closest('.keyboard')) {\n    e.preventDefault();\n  }\n},{passive:false});\n\n// ----------- DEBUG: Load Demo ----------\n/*\nlogs = [\n  {number:1, entries:"(01:25)+(03:10)"},\n  {number:2, entries:"(00:55)"}\n];\nrender();\n*/\n